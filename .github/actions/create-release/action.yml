name: 'Create Convco Release'
description: 'Create a new release based on Conventional Commits'

inputs:
  dry-run:
    description: 'Run in dry-run mode without making actual changes'
    required: false
    default: 'false'
  github-token:
    description: 'GitHub token for creating the release'
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history

    - name: Fetch all tags
      run: |
        git fetch --prune --tags origin
        git fetch --all
      shell: bash

    - name: ASDF Setup
      uses: ./.github/actions/asdf-setup
      with:
        plugins: '["bun@latest"]'

    - name: Determine new version and update package.json
      id: version
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        # Step 1: Get current versions
        echo "ðŸ“¦ Current Versions:"
        current_version=$(node -p "require('./package.json').version")
        latest_tag=$(git tag -l 'v*' --sort=-v:refname | head -n1)
        if [ -z "$latest_tag" ]; then
          echo "No tags found. Using v0.0.0 as base version."
          latest_tag="v0.0.0"
        fi
        latest_version=${latest_tag#v}
        
        echo "  â€¢ package.json: v$current_version"
        echo "  â€¢ Latest tag:   $latest_tag"

        # Step 2: Compute new version
        echo -e "\nðŸ“‹ Commits since $latest_tag:"
        # Include merge commits and show full commit messages
        git log $latest_tag..HEAD --pretty=format:"  â€¢ %s%n    %b" | sed '/^[[:space:]]*$/d'

        echo -e "\nðŸ”„ Computing next version..."
        # Create a temporary copy of package.json for version computation
        cp package.json package.json.temp
        jq --arg version "$latest_version" '.version = $version' package.json.temp > package.json.temp2 && mv package.json.temp2 package.json.temp

        # Use standard-version to compute next version
        if ! bunx standard-version \
          --dry-run \
          --skip.commit \
          --skip.tag \
          --skip.changelog \
          --release-as auto \
          > version_output.txt 2>&1; then
          echo "Error: Failed to determine new version"
          cat version_output.txt  # Show the error output
          rm -f package.json.temp version_output.txt
          exit 1
        fi

        # Extract the computed new version and validate it
        new_version=$(grep "bumping version in package.json from" version_output.txt | awk -F "to " '{print $2}')
        if [ -z "$new_version" ] || [ "$new_version" = "null" ]; then
          echo "Error: Failed to compute new version"
          echo "standard-version output:"
          cat version_output.txt
          rm -f package.json.temp version_output.txt
          exit 1
        fi
        
        # Step 3: Report versions and bump type
        if [ "$(echo $latest_version | cut -d. -f1)" != "$(echo $new_version | cut -d. -f1)" ]; then
          bump_type="major"
        elif [ "$(echo $latest_version | cut -d. -f2)" != "$(echo $new_version | cut -d. -f2)" ]; then
          bump_type="minor"
        else
          bump_type="patch"
        fi
        
        echo -e "\nðŸ“ˆ Version Impact:"
        echo "  â€¢ Current:  $latest_tag"
        echo "  â€¢ Next:     v$new_version"
        echo "  â€¢ Type:     $bump_type bump"

        # Step 4: Make changes if not in dry-run mode
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          echo -e "\nðŸ” DRY RUN - No changes will be made"
          echo "release_needed=false" >> $GITHUB_OUTPUT
        else
          if [ "$current_branch" = "main" ]; then
            echo -e "\nâš¡ Applying changes..."
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git remote set-url origin "https://x-access-token:${env.GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            
            # Run standard-version for real
            if ! bunx standard-version --release-as auto --skip.tag; then
              echo "Error: Failed to create release"
              exit 1
            fi
            
            echo "release_needed=true" >> $GITHUB_OUTPUT
          else
            echo "Not on main branch - skipping release"
            echo "release_needed=false" >> $GITHUB_OUTPUT
          fi
        fi

        # Cleanup
        rm -f package.json.temp version_output.txt
        echo "version=$new_version" >> $GITHUB_OUTPUT

    - name: Commit and Push Changes
      if: steps.version.outputs.release_needed == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git commit -am "chore: release v${{ steps.version.outputs.version }}"
        git push origin HEAD:main

    - name: Generate changelog
      id: changelog
      if: steps.version.outputs.release_needed == 'true'
      shell: bash
      run: |
        # Fetch the latest changes from the remote
        git fetch origin main

        # Check if there are any tags
        if git describe --tags --abbrev=0 --always >/dev/null 2>&1; then
          # Get the latest tag
          latest_tag=$(git describe --tags --abbrev=0 --always)
          # Generate changelog with commit messages since the latest tag up to origin/main
          changelog=$(git log $latest_tag..origin/main --pretty=format:"%s" --no-merges)
        else
          # No tags found, generate changelog from the beginning of the repo up to origin/main
          changelog=$(git log origin/main --pretty=format:"%s" --no-merges)
        fi

        # Output the changelog
        printf "changelog<<EOF\n%s\nEOF\n" "$changelog" >> $GITHUB_ENV

    - name: Create Release
      if: steps.version.outputs.release_needed == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        gh release create v${{ steps.version.outputs.version }} \
          --title "Release ${{ steps.version.outputs.version }}" \
          --notes "${{ steps.changelog.outputs.changelog }}"
